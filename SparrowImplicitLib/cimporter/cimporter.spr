import cImpl.parserIf
import cImpl.sprCodeDump
import cImpl.codeGen

import meta = meta.nodeKinds;

import assert
import time = time

package meta {
    import meta.sparrowNodes, meta.featherNodes, meta.compiler
    import meta.location
}

[macro] fun compileCCode(sourceString: CompilerAstNode): CompilerAstNode
{
    var sourceStr: meta.AstNode = sourceString;
    [ct] if ( (sourceString nodeKind) != meta.nkSparrowExpLiteral )
        meta.report("compileCCode should take a string literal as argument", (sourceStr location));
    else
    {
        sourceStr semanticCheck;
        var loc = sourceStr location;
        var ctx = sourceStr context;
        var str: String = astEval(sourceString clone);
        return handleCCode(str asStringRef, loc, ctx);
    }
}

[ct]
fun handleCCode(code: StringRef, loc: meta.Location, context: meta.CompilationContext): meta.AstNode
    var t: time.Timer
    var res: AstNode
    var filename: StringRef = ""
    var parser: @ParserContext = createParser(filename, code, loc)
    var rootNode = parser parseHeader
    
    //Dump C Code
    dumpCode(cout, rootNode)

    //Generate Sparrow Nodes
    res = genCImporter(rootNode)
    res setContext context
    parser destroyParser

    cout << "Elapsed: " << t.elapsed() << endl << flush
    return res

fun generateSparrowFromC(filename, code: StringRef): String
    var loc: meta.Location = mkLocation()
    var parser: @ParserContext = createParser(filename, code, loc)
    var rootNode = parser parseHeader
    var ss: StringOutputStream

    dumpCode(ss, rootNode)
    return ss.result
