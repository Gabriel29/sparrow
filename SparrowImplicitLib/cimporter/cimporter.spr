import cImpl.parserIf
import cImpl.sprCodeDump
import cImpl.codeGen

import meta = meta.nodeKinds;

import assert
import time = time
import os = os

package meta {
    import meta.sparrowNodes, meta.featherNodes, meta.compiler
    import meta.location
}

[macro] fun compileCCode(sourceString: CompilerAstNode): CompilerAstNode
{
    var sourceStr: meta.AstNode = sourceString;
    [ct] if ( (sourceString nodeKind) != meta.nkSparrowExpLiteral )
        meta.report("compileCCode should take a string literal as argument", (sourceStr location));
    else
    {
        sourceStr semanticCheck;
        var loc = sourceStr location;
        var ctx = sourceStr context;
        var str: String = astEval(sourceString clone);

        var f = File("_tmp_CImp", "w")
        f << str
        f close

        return handleCCode("_tmp_CImp", loc, ctx);
    }
}

[ct]
fun handleCCode(file: StringRef, loc: meta.Location, context: meta.CompilationContext): meta.AstNode
    var t: time.Timer
    var res: AstNode

    os.systemCall("gcc -E -D_STDLIB_H -D_STDIO_H -D_STDARG_H " + file + " > " + file + "_temp")
    var parser: @ParserContext = createParser(file + "_temp", "", loc)
    var rootNode = parser parseHeader

    //Dump C Code
    dumpCode(cout, rootNode)

    //Generate Sparrow Nodes
    res = genCImporter(rootNode)
    res setContext context
    parser destroyParser

    cout << "Elapsed: " << t.elapsed() << endl << flush
    return res

fun generateSparrowFromC(filename, code: StringRef): String
    var loc: meta.Location = mkLocation()
    var parser: @ParserContext = createParser(filename, code, loc)
    var rootNode = parser parseHeader
    var ss: StringOutputStream

    dumpCode(ss, rootNode)
    return ss.result

class CString
    var begin: @Byte
    var alloc: Bool

    fun ctor(ref: StringRef)
        this.begin := malloc(ref.size + 1)
        memcpy(this.begin, ref.begin, ref.size)
        var end: @Byte = ptrAdd(this.begin, ref.size)
        end = Byte(0)
        this.alloc = true

    fun ctor(str: @String)
        var ref = str.asStringRef
        this.begin := ref.begin
        this.alloc = false
    
    fun front: @Char = reinterpretCast(@Char, begin)
    fun release
        if alloc ; begin.free

fun zeroTermString(ref: StringRef): CString
    var c: CString
    c.begin := ref.begin
    c.alloc = false
