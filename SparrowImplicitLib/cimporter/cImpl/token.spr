import meta.location
import std.string

/// A token type; identifies the type of the token
using TokenType = Int

/// The actual token; holds all the information needed for a token
[rtct]
datatype Token
    loc: Location
    type: TokenType
    data: String
    intData: ULong
    floatData: Double

/// Concept modeling the output of the scanner
/// It's basically a range of tokens
concept TokenRange(x: Range) if -@(x.RetType) == Token

// The list of all tokens used by the parser/scanner
using tkEND              = 0
using tkEOL              = 1

using tkIDENTIFIER       = 2
using tkCONSTANT         = 3
using tkSTRING_LITERAL   = 4
using tkSIZEOF           = 5

using tkTYPE_NAME        = 6

using tkPTR_OP           = 10
using tkINC_OP           = 11
using tkDEC_OP           = 12
using tkLEFT_OP          = 13
using tkRIGHT_OP         = 14
using tkLE_OP            = 15
using tkGE_OP            = 16
using tkEQ_OP            = 17
using tkNE_OP            = 18

using tkAND_OP           = 19
using tkOR_OP            = 20
using tkMUL_ASSIGN       = 21
using tkDIV_ASSIGN       = 22
using tkMOD_ASSIGN       = 23
using tkADD_ASSIGN       = 24

using tkSUB_ASSIGN       = 25
using tkLEFT_ASSIGN      = 26
using tkRIGHT_ASSIGN     = 27

using tkAND_ASSIGN       = 28
using tkXOR_ASSIGN       = 29
using tkOR_ASSIGN        = 30

using tkTYPEDEF          = 31
using tkEXTERN           = 32
using tkSTATIC           = 33
using tkAUTO             = 34
using tkREGISTER         = 35

using tkCHAR             = 40
using tkSHORT            = 41
using tkINT              = 42
using tkLONG             = 43
using tkSIGNED           = 44
using tkUNSIGNED         = 45
using tkFLOAT            = 46
using tkDOUBLE           = 47
using tkCONST            = 48
using tkVOLATILE         = 49
using tkVOID             = 67

using tkSTRUCT           = 50
using tkUNION            = 51
using tkENUM             = 52
using tkELLIPSIS         = 53

using tkCASE             = 54
using tkDEFAULT          = 55
using tkIF               = 56
using tkELSE             = 57
using tkSWITCH           = 58
using tkWHILE            = 59
using tkDO               = 60
using tkFOR              = 61
using tkGOTO             = 62
using tkCONTINUE         = 63
using tkBREAK            = 64
using tkRETURN           = 65

using tkSEMICOLON        = 68
using tkLCURLY           = 69
using tkRCURLY           = 70
using tkCOMMA            = 71
using tkCOLON            = 72
using tkEQUAL            = 73
using tkLPAREN           = 74
using tkRPAREN           = 75
using tkLBRACKET         = 76
using tkRBRACKET         = 77
using tkDOT              = 78
using tkAMPERSAND        = 79
using tkNOT              = 80
using tkTILDA            = 81
using tkMINUS            = 82
using tkPLUS             = 83
using tkMUL              = 84
using tkDIV              = 85
using tkMOD              = 86
using tkLT               = 87
using tkGT               = 88
using tkXOR              = 89
using tkOR               = 90
using tkQMARK            = 91

using tkINLINE           = 100

using tkCHAR_LITERAL     = 200
using tkINT_LITERAL      = 201
using tkUINT_LITERAL     = 202
using tkFLOAT_LITERAL    = 203
using tkUFLOAT_LITERAL   = 204
using tkDOUBLE_LITERAL   = 205


// C Preprocessor tokens
/*
using ptkDEFINE             = TokenType(100)
using ptkINCLUDE            = TokenType(101)
using ptkUNDEF              = TokenType(102)
using ptkIFDEF              = TokenType(103)
using ptkIFNDEF             = TokenType(104)
using ptkIF                 = TokenType(105)
using ptkELSE               = TokenType(106)
using ptkELIF               = TokenType(107)
using ptkENDIF              = TokenType(108)
using ptkERROR              = TokenType(109)
using ptkPRAGMA             = TokenType(110)
*/

[rtct]
fun token_asString(t: TokenType): String
    if t == tkEND                   return "end-of-file"
    else if t == tkEOL              return "new-line"
    else if t == tkIDENTIFIER       return "identifier"
    else if t == tkCONSTANT         return "constant"
    else if t == tkSTRING_LITERAL   return "string"
    else if t == tkSIZEOF           return "'sizeof'"

    else if t == tkTYPE_NAME        return "type_name"

    else if t == tkPTR_OP           return "'->'"
    else if t == tkINC_OP           return "'++'"
    else if t == tkDEC_OP           return "'--'"
    else if t == tkLEFT_OP          return "'<<'"
    else if t == tkRIGHT_OP         return "'>>'"
    else if t == tkLE_OP            return "'<='"
    else if t == tkGE_OP            return "'>='"
    else if t == tkEQ_OP            return "'=='"
    else if t == tkNE_OP            return "'!='"

    else if t == tkAND_OP           return "'&&'"
    else if t == tkOR_OP            return "'||'"
    else if t == tkMUL_ASSIGN       return "'*='"
    else if t == tkDIV_ASSIGN       return "'/='"
    else if t == tkMOD_ASSIGN       return "'%='"
    else if t == tkADD_ASSIGN       return "'+='"

    else if t == tkSUB_ASSIGN       return "'-='"
    else if t == tkLEFT_ASSIGN      return "'<=='"
    else if t == tkRIGHT_ASSIGN     return "'>=='"

    else if t == tkAND_ASSIGN       return "'&='"
    else if t == tkXOR_ASSIGN       return "'^='"
    else if t == tkOR_ASSIGN        return "'|='"

    else if t == tkTYPEDEF          return "'typedef'"
    else if t == tkEXTERN           return "'extern'"
    else if t == tkSTATIC           return "'static'"
    else if t == tkAUTO             return "'auto'"
    else if t == tkREGISTER         return "'register'"

    else if t == tkCHAR             return "'char'"
    else if t == tkSHORT            return "'short'"
    else if t == tkINT              return "'int'"
    else if t == tkLONG             return "'long'"
    else if t == tkSIGNED           return "'signed'"
    else if t == tkUNSIGNED         return "'unsigned'"
    else if t == tkFLOAT            return "'float'"
    else if t == tkDOUBLE           return "'double'"
    else if t == tkCONST            return "'const'"
    else if t == tkVOLATILE         return "'volatile'"
    else if t == tkVOID             return "'void'"
    
    else if t == tkSTRUCT           return "'struct'"
    else if t == tkUNION            return "'union'"
    else if t == tkENUM             return "'enum'"
    else if t == tkELLIPSIS         return "'...'"
    
    else if t == tkCASE             return "'case'"
    else if t == tkDEFAULT          return "'default'"
    else if t == tkIF               return "'if'"
    else if t == tkELSE             return "'else'"
    else if t == tkSWITCH           return "'switch'"
    else if t == tkWHILE            return "'while'"
    else if t == tkDO               return "'do'"
    else if t == tkFOR              return "'for'"
    else if t == tkGOTO             return "'goto'"
    else if t == tkCONTINUE         return "'continue'"
    else if t == tkBREAK            return "'break'"
    else if t == tkRETURN           return "'return'"

    else if t == tkINLINE           return "'inline'"

    else if t == tkSEMICOLON        return "';'"
    else if t == tkLCURLY           return "'{'"
    else if t == tkRCURLY           return "'}'"
    else if t == tkCOMMA            return "','"
    else if t == tkCOLON            return "':'"
    else if t == tkEQUAL            return "'='"
    else if t == tkLPAREN           return "'('"
    else if t == tkRPAREN           return "')'"
    else if t == tkLBRACKET         return "'['"
    else if t == tkRBRACKET         return "']'"
    else if t == tkDOT              return "'.'"
    else if t == tkAMPERSAND        return "'&'"
    else if t == tkNOT              return "'!'"
    else if t == tkTILDA            return "'~'"
    else if t == tkMINUS            return "'-'"
    else if t == tkPLUS             return "'+'"
    else if t == tkMUL              return "'*'"
    else if t == tkDIV              return "'/'"
    else if t == tkMOD              return "'%'"
    else if t == tkLT               return "'<'"
    else if t == tkGT               return "'>'"
    else if t == tkXOR              return "'^'"
    else if t == tkOR               return "'|'"
    else if t == tkQMARK            return "'?'"

    else if t == tkCHAR_LITERAL     return "char literal"
    else if t == tkINT_LITERAL      return "int literal"
    else if t == tkUINT_LITERAL     return "uint literal"

    else if t == tkFLOAT_LITERAL     return "float literal"
    else if t == tkUFLOAT_LITERAL    return "ufloat literal"

    else if t == tkDOUBLE_LITERAL    return "double literal"


    // C Preprocessor tokens
    /*
    else if t == ptkDEFINE          return "'define'"
    else if t == ptkINCLUDE         return "'include'"
    else if t == ptkUNDEF           return "'undef'"
    else if t == ptkIFDEF           return "'ifdef'"
    else if t == ptkIFNDEF          return "'if'"
    else if t == ptkIF              return "'else'"
    else if t == ptkELSE            return "'elif'"
    else if t == ptkELIF            return "'endif'"
    else if t == ptkERROR           return "'error'"
    else if t == ptkPRAGMA          return "'pragma'"
    */

//[rtct]
//fun >>(t: TokenType, os: @OutStream)
//    os << (t _asString)
