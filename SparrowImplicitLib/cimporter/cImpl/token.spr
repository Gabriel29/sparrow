import meta.location
import std.string

/// A token type; identifies the type of the token
[rtct]
datatype TokenType = Int

/// The actual token; holds all the information needed for a token
[rtct]
datatype Token
    loc: Location
    type: TokenType
    data: String
    intData: ULong
    floatData: Double

/// Concept modeling the output of the scanner
/// It's basically a range of tokens
concept TokenRange(x: Range) if -@(x.RetType) == Token

// The list of all tokens used by the parser/scanner
[rtct]
    var tkEND              = TokenType(0)
    var tkEOL              = TokenType(1)

    var tkIDENTIFIER       = TokenType(2)
    var tkCONSTANT         = TokenType(3)
    var tkSTRING_LITERAL   = TokenType(4)
    var tkSIZEOF           = TokenType(5)

    var tkTYPE_NAME        = TokenType(6)

    var tkPTR_OP           = TokenType(10)
    var tkINC_OP           = TokenType(11)
    var tkDEC_OP           = TokenType(12)   
    var tkLEFT_OP          = TokenType(13)
    var tkRIGHT_OP         = TokenType(14)
    var tkLE_OP            = TokenType(15)
    var tkGE_OP            = TokenType(16)
    var tkEQ_OP            = TokenType(17)
    var tkNE_OP            = TokenType(18)

    var tkAND_OP           = TokenType(19)
    var tkOR_OP            = TokenType(20)
    var tkMUL_ASSIGN       = TokenType(21)
    var tkDIV_ASSIGN       = TokenType(22)
    var tkMOD_ASSIGN       = TokenType(23)
    var tkADD_ASSIGN       = TokenType(24)

    var tkSUB_ASSIGN       = TokenType(25)
    var tkLEFT_ASSIGN      = TokenType(26)
    var tkRIGHT_ASSIGN     = TokenType(27)

    var tkAND_ASSIGN       = TokenType(28)
    var tkXOR_ASSIGN       = TokenType(29)
    var tkOR_ASSIGN        = TokenType(30)

    var tkTYPEDEF          = TokenType(31)
    var tkEXTERN           = TokenType(32)
    var tkSTATIC           = TokenType(33)
    var tkAUTO             = TokenType(34)
    var tkREGISTER         = TokenType(35)

    var tkCHAR             = TokenType(40)
    var tkSHORT            = TokenType(41)
    var tkINT              = TokenType(42)
    var tkLONG             = TokenType(43)
    var tkSIGNED           = TokenType(44)
    var tkUNSIGNED         = TokenType(45)
    var tkFLOAT            = TokenType(46)
    var tkDOUBLE           = TokenType(47)
    var tkCONST            = TokenType(48)
    var tkVOLATILE         = TokenType(49)
    var tkVOID             = TokenType(67)

    var tkSTRUCT           = TokenType(50)
    var tkUNION            = TokenType(51)
    var tkENUM             = TokenType(52)
    var tkELLIPSIS         = TokenType(53)

    var tkCASE             = TokenType(54)
    var tkDEFAULT          = TokenType(55)
    var tkIF               = TokenType(56)
    var tkELSE             = TokenType(57)
    var tkSWITCH           = TokenType(58)
    var tkWHILE            = TokenType(59)
    var tkDO               = TokenType(60)
    var tkFOR              = TokenType(61)
    var tkGOTO             = TokenType(62)
    var tkCONTINUE         = TokenType(63)
    var tkBREAK            = TokenType(64)
    var tkRETURN           = TokenType(65)

    var tkSEMICOLON        = TokenType(68)
    var tkLCURLY           = TokenType(69)
    var tkRCURLY           = TokenType(70)
    var tkCOMMA            = TokenType(71)
    var tkCOLON            = TokenType(72)
    var tkEQUAL            = TokenType(73)
    var tkLPAREN           = TokenType(74)
    var tkRPAREN           = TokenType(75)
    var tkLBRACKET         = TokenType(76)
    var tkRBRACKET         = TokenType(77)
    var tkDOT              = TokenType(78)
    var tkAMPERSAND        = TokenType(79)
    var tkNOT              = TokenType(80)
    var tkTILDA            = TokenType(81)
    var tkMINUS            = TokenType(82)
    var tkPLUS             = TokenType(83)
    var tkMUL              = TokenType(84)
    var tkDIV              = TokenType(85)
    var tkMOD              = TokenType(86)
    var tkLT               = TokenType(87)
    var tkGT               = TokenType(88)
    var tkXOR              = TokenType(89)
    var tkOR               = TokenType(90)
    var tkQMARK            = TokenType(91)

    var tkCHAR_LITERAL     = TokenType(200)
    var tkINT_LITERAL      = TokenType(201)
    var tkUINT_LITERAL     = TokenType(202)
    var tkFLOAT_LITERAL    = TokenType(203)
    var tkUFLOAT_LITERAL   = TokenType(204)
    var tkDOUBLE_LITERAL   = TokenType(205)


// C Preprocessor tokens
/*
using ptkDEFINE             = TokenType(100)
using ptkINCLUDE            = TokenType(101)
using ptkUNDEF              = TokenType(102)
using ptkIFDEF              = TokenType(103)
using ptkIFNDEF             = TokenType(104)
using ptkIF                 = TokenType(105)
using ptkELSE               = TokenType(106)
using ptkELIF               = TokenType(107)
using ptkENDIF              = TokenType(108)
using ptkERROR              = TokenType(109)
using ptkPRAGMA             = TokenType(110)
*/

[rtct]
fun _asString(t: TokenType): String
    if t == tkEND                   return "end-of-file"
    else if t == tkEOL              return "new-line"
    else if t == tkIDENTIFIER       return "identifier"
    else if t == tkCONSTANT         return "constant"
    else if t == tkSTRING_LITERAL   return "string"
    else if t == tkSIZEOF           return "'sizeof'"

    else if t == tkTYPE_NAME        return "type_name"

    else if t == tkPTR_OP           return "'->'"
    else if t == tkINC_OP           return "'++'"
    else if t == tkDEC_OP           return "'--'"
    else if t == tkLEFT_OP          return "'<<'"
    else if t == tkRIGHT_OP         return "'>>'"
    else if t == tkLE_OP            return "'<='"
    else if t == tkGE_OP            return "'>='"
    else if t == tkEQ_OP            return "'=='"
    else if t == tkNE_OP            return "'!='"

    else if t == tkAND_OP           return "'&&'"
    else if t == tkOR_OP            return "'||'"
    else if t == tkMUL_ASSIGN       return "'*='"
    else if t == tkDIV_ASSIGN       return "'/='"
    else if t == tkMOD_ASSIGN       return "'%='"
    else if t == tkADD_ASSIGN       return "'+='"

    else if t == tkSUB_ASSIGN       return "'-='"
    else if t == tkLEFT_ASSIGN      return "'<=='"
    else if t == tkRIGHT_ASSIGN     return "'>=='"

    else if t == tkAND_ASSIGN       return "'&='"
    else if t == tkXOR_ASSIGN       return "'^='"
    else if t == tkOR_ASSIGN        return "'|='"

    else if t == tkTYPEDEF          return "'typedef'"
    else if t == tkEXTERN           return "'extern'"
    else if t == tkSTATIC           return "'static'"
    else if t == tkAUTO             return "'auto'"
    else if t == tkREGISTER         return "'register'"

    else if t == tkCHAR             return "'char'"
    else if t == tkSHORT            return "'short'"
    else if t == tkINT              return "'int'"
    else if t == tkLONG             return "'long'"
    else if t == tkSIGNED           return "'signed'"
    else if t == tkUNSIGNED         return "'unsigned'"
    else if t == tkFLOAT            return "'float'"
    else if t == tkDOUBLE           return "'double'"
    else if t == tkCONST            return "'const'"
    else if t == tkVOLATILE         return "'volatile'"
    else if t == tkVOID             return "'void'"
    
    else if t == tkSTRUCT           return "'struct'"
    else if t == tkUNION            return "'union'"
    else if t == tkENUM             return "'enum'"
    else if t == tkELLIPSIS         return "'...'"
    
    else if t == tkCASE             return "'case'"
    else if t == tkDEFAULT          return "'default'"
    else if t == tkIF               return "'if'"
    else if t == tkELSE             return "'else'"
    else if t == tkSWITCH           return "'switch'"
    else if t == tkWHILE            return "'while'"
    else if t == tkDO               return "'do'"
    else if t == tkFOR              return "'for'"
    else if t == tkGOTO             return "'goto'"
    else if t == tkCONTINUE         return "'continue'"
    else if t == tkBREAK            return "'break'"
    else if t == tkRETURN           return "'return'"

    else if t == tkSEMICOLON        return "';'"
    else if t == tkLCURLY           return "'{'"
    else if t == tkRCURLY           return "'}'"
    else if t == tkCOMMA            return "','"
    else if t == tkCOLON            return "':'"
    else if t == tkEQUAL            return "'='"
    else if t == tkLPAREN           return "'('"
    else if t == tkRPAREN           return "')'"
    else if t == tkLBRACKET         return "'['"
    else if t == tkRBRACKET         return "']'"
    else if t == tkDOT              return "'.'"
    else if t == tkAMPERSAND        return "'&'"
    else if t == tkNOT              return "'!'"
    else if t == tkTILDA            return "'~'"
    else if t == tkMINUS            return "'-'"
    else if t == tkPLUS             return "'+'"
    else if t == tkMUL              return "'*'"
    else if t == tkDIV              return "'/'"
    else if t == tkMOD              return "'%'"
    else if t == tkLT               return "'<'"
    else if t == tkGT               return "'>'"
    else if t == tkXOR              return "'^'"
    else if t == tkOR               return "'|'"
    else if t == tkQMARK            return "'?'"

    else if t == tkCHAR_LITERAL     return "char literal"
    else if t == tkINT_LITERAL      return "int literal"
    else if t == tkUINT_LITERAL     return "uint literal"

    else if t == tkFLOAT_LITERAL     return "float literal"
    else if t == tkUFLOAT_LITERAL    return "ufloat literal"

    else if t == tkDOUBLE_LITERAL    return "double literal"


    // C Preprocessor tokens
    /*
    else if t == ptkDEFINE          return "'define'"
    else if t == ptkINCLUDE         return "'include'"
    else if t == ptkUNDEF           return "'undef'"
    else if t == ptkIFDEF           return "'ifdef'"
    else if t == ptkIFNDEF          return "'if'"
    else if t == ptkIF              return "'else'"
    else if t == ptkELSE            return "'elif'"
    else if t == ptkELIF            return "'endif'"
    else if t == ptkERROR           return "'error'"
    else if t == ptkPRAGMA          return "'pragma'"
    */

[rtct]
fun >>(t: TokenType, os: @OutStream)
    os << (t _asString)
