import parserDefs, token, rangeWithLookahead, nodes
import meta.location
import bitOper
import os

/// Our main parser
///
/// Takes as an input a range of tokens (produced by the scanner) and produces
/// a node as a result. The node is in fast and AST (tree).
///
/// All the nodes are created outside the parser; we only care about node pointers
///
[rtct]
class SparrowParser(tokensRangeType, errorReporterType: Type) \
        if TokenRange(#$tokensRangeType) && ErrorReporter(#$errorReporterType)

    fun ctor(tokens: tokensRangeType, errorReporter: errorReporterType)
        this._tokens ctor tokens
        this._hasErrors ctor false
        this._errorReporter ctor errorReporter

    /// The source ranges of tokens we will used while parsing
    var _tokens: RangeWithLookahead(tokensRangeType)
    /// The last processed token
    var _lastToken: Token
    /// Indicates whether we have some syntax errors
    var _hasErrors: Bool
    /// Object used to report errors
    var _errorReporter: errorReporterType

using parseHeader = _Impl.parseHeader

package _Impl
    [rtct]
        // TypeName List
        var _ignore: Bool
        var _typeNameList: Vector(String)
        var _typeNameListIgnore: Vector(String)

        fun reportError(this: @SparrowParser, msg: StringRef)
            // Report the error
            _errorReporter.reportError((*_tokens).loc, msg)
            // Consume all the tokens until the end of the file
            while (*_tokens).type != tkEND
                _lastToken = (_tokens++)
            _hasErrors = true

        fun curLoc(this: @SparrowParser) = (*_tokens).loc
        fun lastLoc(this: @SparrowParser) = _lastToken.loc

        fun nextIs(this: @SparrowParser, t: TokenType): Bool = (*_tokens).type == t
        fun next2Is(this: @SparrowParser, t: TokenType): Bool = (_tokens peek 1).type == t
        fun nextNIs(this: @SparrowParser, t: TokenType, n: Int): Bool = (_tokens peek n).type == t

        fun nextIsTypeName(this: @SparrowParser): Bool
            if (*_tokens).type == tkIDENTIFIER
                for name: String = _typeNameList.all()
                    if name == (*_tokens).data
                        return true

            return false

        fun nextIsTypeNameIgnore(this: @SparrowParser): Bool
            if (*_tokens).type == tkIDENTIFIER
                for name: String = _typeNameListIgnore.all()
                    if name == (*_tokens).data
                        _ignore = true
                        return true
            return false

        fun accept(this: @SparrowParser, t: TokenType): Bool
            if (*_tokens).type == t
                //TODO
                //_lastToken = (_tokens++)
                _lastToken ctor (_tokens++)
                //cout << "Accepted " << token_asString(_lastToken.type) << endl

                return true
            return false

        fun expect(this: @SparrowParser, t: TokenType): Bool
            // Everything is ok if this is the token we are expecting
            if this accept t
                return true
            if _hasErrors  // Already inside an error; don't do anything
                return false
            // Report error if this token is now what we expected
            
            this reportError toString("Syntax error, unexpected ", (*_tokens).type, ", expecting ", t).asStringRef
            return false

        //TODO - Check why @String not working for Return Type
        fun expect(this: @SparrowParser, b: Bool, msg: StringRef): Bool 
            if b == false
                this reportError msg
            return true

        // Top level parsing
        fun parseHeader(this: @SparrowParser): NodePtr
            var res = parseExtDecls(this)
            this expect tkEND

            return res

        fun doWorkAround(this: @SparrowParser, resNodes: @NodePtr)
            // Workaround from size_t
            var loc: Location
            var ttt = mkType(_lastToken.loc, "PrimitiveType", "Int", NodePtr())
            var size_t = mkTypedef(loc, "size_t", ttt)
            resNodes = addToNodeList(resNodes, size_t)
            _typeNameList += String("size_t")

            _typeNameListIgnore += String("FILE")
            _typeNameListIgnore += String("va_list")

        fun parseExtDecls(this: @SparrowParser): NodePtr
            var resNodes: NodePtr

            doWorkAround(this, resNodes)

            while true
                _ignore = false

                var decl, init, body: NodePtr
                var storSpec, typeSpec, structDecl, funcSpec: NodePtr
                
                if !parseDeclarationSpecifiers(this, storSpec, typeSpec, structDecl, funcSpec)
                    break
                
                // Add structure declaration to ExtDecls
                if structDecl isSet
                    resNodes = addToNodeList(resNodes, structDecl)

                if (this accept tkSEMICOLON)
                    continue
                
                expect(this, parseDeclarator(this, storSpec, typeSpec, decl), "expecting declarator")
                
                // Parse Function Body
                var s = parseCompoundStmt(this, body)
                if body isSet
                    decl->children.at(3) = body
                    continue

                if s == true
                    decl->kind = String("skipMe")
                    continue

                // Parse Variable initializer
                if this accept tkEQUAL
                    parseInitializer(this, init)
                    // VarDecl Only 
                    decl->children.at(2) = init
                
                resNodes = addToNodeList(resNodes, decl)

                while this accept tkCOMMA
                    expect(this, parseDeclarator(this, storSpec, typeSpec, decl), "expecting declarator")
                    if this accept tkEQUAL
                        parseInitializer(this, init)
                        decl->children.at(2) = init
                    
                    resNodes = addToNodeList(resNodes, decl)

                this expect tkSEMICOLON

            return resNodes

        fun parsePrimaryExpression(this: @SparrowParser, expr: @NodePtr): Bool
            if this accept tkIDENTIFIER
                expr = mkIdentifier(_lastToken.loc, _lastToken.data asStringRef)
                return true

            else if this accept tkSTRING_LITERAL
                expr = mkStringLiteral(_lastToken.loc, _lastToken.data asStringRef)
                return true

            else if this accept tkCHAR_LITERAL
                expr = mkCharLiteral(_lastToken.loc, _lastToken.data asStringRef)
                return true

            else if this accept tkINT_LITERAL
                expr = mkIntLiteral(_lastToken.loc, _lastToken.intData)
                return true

            else if this accept tkUINT_LITERAL
                expr = mkUIntLiteral(_lastToken.loc, _lastToken.intData)
                return true

            else if this accept tkFLOAT_LITERAL
                expr = mkFloatLiteral(_lastToken.loc, _lastToken.floatData)
                return true

            else if this accept tkDOUBLE_LITERAL
                expr = mkDoubleLiteral(_lastToken.loc, _lastToken.floatData)
                return true

            else if this accept tkLPAREN
                var loc = _lastToken.loc
                var expr2: NodePtr
                parseExpression(this, expr2)
                this expect tkRPAREN

                expr = mkParenthesisExpr(loc, expr2)
                return true

            //else if this accept tkCONSTANT
            //    return true
            
            return false

        fun parsePostfixExpression(this: @SparrowParser, expr: @NodePtr): Bool
            if this accept tkLPAREN
                var typeName, list: NodePtr
                //parseTypeName(this, typeName)
                this expect tkLCURLY
                //expect(this, parseInitializerList(this, list), "expecting initializer list")
                this accept tkCOMMA
                this expect tkRCURLY
                this expect tkRPAREN
                return true

            if !parsePrimaryExpression(this, expr)
                return false

            /*while 
                if this accept tkLBRACKET
                    this expect tkRBRACKET
                else if this accept tkLPAREN
                    parseArgumentExpressionlist(this)
                    this expect tkRPAREN
                else if this accept tkDOT
                    this expect tkIDENTIFIER
                else if this accept tkPTR_OP
                    this expect tkIDENTIFIER
                else if this accept tkINC_OP
                    break
                else if this accept tkDEC_OP
                    break
                else
                    break
            */

            return true
        
        //TODO
        fun parseArgumentExpressionlist(this: @SparrowParser): Bool
            var res: Bool
            res = parseAssignmentExpression(this)

            while res == true && (this accept tkCOMMA)
                parseAssignmentExpression(this)

            if res == true
                return true

            this reportError toString("Syntax error, unexpected ", (*_tokens).type, ", expecting AssignExpr")

        fun parseUnaryExpression(this: @SparrowParser, expr: @NodePtr): Bool
            if this accept tkINC_OP
                expect(this, parseUnaryExpression(this, expr), "expecting unary expression")
                expr = mkUnaryExpr(_lastToken.loc, expr, "++")
            else if this accept tkDEC_OP
                expect(this, parseUnaryExpression(this, expr), "expecting unary expression")
                expr = mkUnaryExpr(_lastToken.loc, expr, "--")

            else if this accept tkSIZEOF
                if this accept tkLPAREN
                    var typeName: NodePtr
                    // TODO
                    //expect(this, parseTypeName(this, typeName), "expecting TypeName")
                    this expect tkRPAREN
                    return true
                else
                    expect(this, parseUnaryExpression(this, expr), "expecting unary expression")

            else if parseUnaryOperator(this)
                var loc = _lastToken.loc
                var op  = _lastToken.data
                expect(this, parseCastExpression(this, expr), "expecting cast expression")
                expr = mkUnaryExpr(_lastToken.loc, expr, op asStringRef)
            
            return parsePostfixExpression(this, expr)
                
        fun parseUnaryOperator(this: @SparrowParser): Bool
            if  (  (this accept tkAMPERSAND)
                || (this accept tkMUL)
                || (this accept tkPLUS)
                || (this accept tkMINUS)
                || (this accept tkTILDA)
                || (this accept tkNOT)
                )
                return true

            return false

        fun parseCastExpression(this: @SparrowParser, expr: @NodePtr): Bool
            while this accept tkLPAREN
                var typeToCast: NodePtr
                // TODO
                //parseTypeName(this, typeToCast)
                expr = mkCast(_lastToken.loc, typeToCast, expr)
                this expect tkRPAREN

            return parseUnaryExpression(this, expr)

        fun parseBinOp(this: @SparrowParser): Bool
            if  (  (this accept tkMUL)
                || (this accept tkDIV)
                || (this accept tkMOD)
                || (this accept tkPLUS)
                || (this accept tkMINUS)
                || (this accept tkLEFT_OP)
                || (this accept tkRIGHT_OP)
                || (this accept tkLT)
                || (this accept tkGT)
                || (this accept tkLE_OP)
                || (this accept tkGE_OP)
                || (this accept tkEQ_OP)
                || (this accept tkNE_OP)
                || (this accept tkAMPERSAND)
                || (this accept tkXOR)
                || (this accept tkOR)
                || (this accept tkAND_OP)
                || (this accept tkOR_OP)
                )
                return true

            return false

        fun binExprOp(this: @SparrowParser, expr: @NodePtr): Bool
            if !parseCastExpression(this, expr)
                return false

            while this parseBinOp
                var name = _lastToken.data
                var loc  = _lastToken.loc
                var expr2: NodePtr
                expect(this, parseCastExpression(this, expr2),
                        "expected Logical And Expression")
                expr = mkBinOper(loc, expr, expr2, name.asStringRef)

            return true

        fun parseConditionalExpression(this: @SparrowParser, res: @NodePtr): Bool
            if !binExprOp(this, res)
                return false
            
            // TODO
            if this accept tkQMARK
                var expr, cond: NodePtr
                expect(this, parseExpression(this, expr), "expecting expression")
                this expect tkCOLON
                expect(this, parseConditionalExpression(this, cond), "expecting conditionalExpression")

            return true

        fun parseAssignmentExpression(this: @SparrowParser, init: @NodePtr): Bool
            //while (parseUnaryExpression(this) && parseAssignmentOperator(this))
            //    continue

            if !parseConditionalExpression(this, init)
                return false

            return true

        fun parseAssignmentOperator(this: @SparrowParser): Bool
            if this accept tkEQUAL
                return true
            else if this accept tkMUL_ASSIGN
                return true
            else if this accept tkDIV_ASSIGN
                return true
            else if this accept tkMOD_ASSIGN
                return true
            else if this accept tkADD_ASSIGN
                return true
            else if this accept tkSUB_ASSIGN
                return true
            else if this accept tkLEFT_ASSIGN
                return true
            else if this accept tkRIGHT_ASSIGN
                return true
            else if this accept tkAND_ASSIGN
                return true
            else if this accept tkXOR_ASSIGN
                return true
            else if this accept tkOR_ASSIGN
                return true

            return false

        fun parseExpression(this: @SparrowParser, res: @NodePtr): Bool
            if !parseAssignmentExpression(this, res)
                return false

            while this accept tkCOMMA
                expect(this, parseAssignmentExpression(this, res), "expecting assignment expression")

            return true

        fun parseConstantExpression(this: @SparrowParser, res: @NodePtr): Bool
            return parseConditionalExpression(this, res)

        fun parseInitializer(this: @SparrowParser, init: @NodePtr): Bool
            if this accept tkLCURLY
                //expect(this, parseInitializerList(this), "expecting Initializer List")
                this accept tkCOMMA
                this expect tkRCURLY
                return true

            else if parseAssignmentExpression(this, init)
                return true

            return false

        // TODO
        fun parseInitializerList(this: @SparrowParser): Bool
            var res: Bool
            
            res = ( parseDesignator(this)
                 || parseInitializer(this)
                 )

            while res == true && (this accept tkCOMMA)
                parseDesignator(this)
                parseInitializer(this)
            //this reportError toString("Syntax error, unexpected ", (*_tokens).type, ", expecting parseInitializerList")
            return res


        fun parseDeclarationSpecifiers(this: @SparrowParser, \
                storSpec, typeSpec, structDecl, funcSpec: @NodePtr): Bool
            var typeQual: NodePtr

            if !( parseStorageClassSpecifier(this, storSpec)
                    || parseTypeSpecifier(this, typeSpec)
                    || parseTypeQualifier(this, typeQual)
                    || parseStructOrUnionSpecifier(this, typeSpec, structDecl) 
                    || parseEnumSpecifier(this, typeSpec, structDecl)
                    || parseFunctionSpecifier(this, funcSpec)
                    )
                return false

            while true
                if !(parseStorageClassSpecifier(this, storSpec)
                    || parseTypeSpecifier(this, typeSpec)
                    || parseTypeQualifier(this, typeQual)
                    || parseStructOrUnionSpecifier(this, typeSpec, structDecl) 
                    || parseEnumSpecifier(this, typeSpec, structDecl)
                    || parseFunctionSpecifier(this, funcSpec)
                    )
                    break;

            typeSpec->children.at(0) = typeQual
            return true

        fun isTypeSpecifier(this: @SparrowParser, n: Int): Bool
            if ( nextNIs(this, tkVOID, n)
              || nextNIs(this, tkCHAR, n)
              || nextNIs(this, tkSHORT, n)
              || nextNIs(this, tkINT, n)
              || nextNIs(this, tkLONG, n)
              || nextNIs(this, tkFLOAT, n)
              || nextNIs(this, tkDOUBLE, n)
              || nextNIs(this, tkSIGNED, n)
              || nextNIs(this, tkUNSIGNED, n)
              || nextNIs(this, tkIDENTIFIER, n) // TYPENAME
              )
                return true
            return false
        fun isStorageClassSpecifier(this: @SparrowParser, n: Int): Bool
            if ( nextNIs(this, tkTYPEDEF, n)
              || nextNIs(this, tkEXTERN, n)
              || nextNIs(this, tkSTATIC, n)
              || nextNIs(this, tkAUTO, n)
              || nextNIs(this, tkREGISTER, n)
              )
                return true
            return false
        fun isTypeQualifier(this: @SparrowParser, n: Int): Bool
            if ( nextNIs(this, tkCONST, n)
              || nextNIs(this, tkVOLATILE, n)
              )
                return true
            return false

        fun parseFunctionSpecifier(this: @SparrowParser, funcSpec: @NodePtr): Bool
            if this accept tkINLINE
                funcSpec = mkIdentifier(_lastToken.loc, "inline")
                return true

            return false

        fun parseStorageClassSpecifier(this: @SparrowParser, storSpec: @NodePtr): Bool
            if this accept tkTYPEDEF
                storSpec = mkIdentifier(_lastToken.loc, "Typedef")
                return true
            if this accept tkEXTERN
                storSpec = mkIdentifier(_lastToken.loc, "Extern")
                return true
            if this accept tkSTATIC
                storSpec = mkIdentifier(_lastToken.loc, "Static")
                return true
            if this accept tkAUTO
                storSpec = mkIdentifier(_lastToken.loc, "Auto")
                return true
            if this accept tkREGISTER
                storSpec = mkIdentifier(_lastToken.loc, "Register")
                return true

            return false

        fun parseTypeSpecifier(this: @SparrowParser, type: @NodePtr): Bool
            if this accept tkVOID
                type = mkType(_lastToken.loc, "PrimitiveType", "Void", NodePtr())
                return true
            if this accept tkCHAR
                type = mkType(_lastToken.loc, "PrimitiveType", "Char", NodePtr())
                return true
            if this accept tkSHORT
                type = mkType(_lastToken.loc, "PrimitiveType", "Short", NodePtr())
                return true
            if this accept tkINT
                type = mkType(_lastToken.loc, "PrimitiveType", "Int", NodePtr())
                return true
            if this accept tkLONG
                type = mkType(_lastToken.loc, "PrimitiveType", "Long", NodePtr())
                return true
            if this accept tkFLOAT
                type = mkType(_lastToken.loc, "PrimitiveType", "Float", NodePtr())
                return true
            if this accept tkDOUBLE
                type = mkType(_lastToken.loc, "PrimitiveType", "Double", NodePtr())
                return true
            if this accept tkSIGNED
                type = mkType(_lastToken.loc, "PrimitiveType", "Signed", NodePtr())
                return true
            if this accept tkUNSIGNED
                type = mkType(_lastToken.loc, "PrimitiveType", "Unsigned", NodePtr())
                return true
            //if this accept tkTYPE_NAME
            if this nextIsTypeName
                this accept tkIDENTIFIER
                type = mkType(_lastToken.loc, "PrimitiveType", _lastToken.data.asStringRef, NodePtr())
                //type = mkIdentifier(_lastToken.loc, _lastToken.data.asStringRef)
                return true

            if this nextIsTypeNameIgnore
                this accept tkIDENTIFIER
                type = mkType(_lastToken.loc, "PrimitiveType", _lastToken.data.asStringRef, NodePtr())
                //type = mkIdentifier(_lastToken.loc, _lastToken.data.asStringRef)
                return true

            return false
        
        fun parseTypeQualifier(this: @SparrowParser, list: @NodePtr): Bool
            if this accept tkCONST
                list = addToNodeList(list, new(Node, _lastToken.loc, "Const"))
                return true
            else if this accept tkVOLATILE
                list = addToNodeList(list, new(Node, _lastToken.loc, "Volatile"))
                return true

            return false
        
        fun parseStructOrUnionSpecifier(this: @SparrowParser, type, decl: @NodePtr): Bool
            var typeString: StringRef
            var loc: Location

            if this accept tkSTRUCT
                loc = _lastToken.loc
                typeString = "Struct"
            else if this accept tkUNION
                loc = _lastToken.loc
                typeString = "Union"
            else return false

            if this accept tkIDENTIFIER
                var name = _lastToken.data
                type = mkType(_lastToken.loc, typeString + "Type", name asStringRef, NodePtr())

                if this accept tkLCURLY
                    var list = NodePtr()
                    while true
                        if !parseStructDeclaration(this, list)
                            break

                    this expect tkRCURLY
                    decl = mkStructDecl(loc, typeString + "Decl", name asStringRef, list)

            else if this accept tkLCURLY
                var name: String = "struct"
                name = name + ulongToString(_lastToken.loc.start.line) + ulongToString(_lastToken.loc.start.col)
                //cout << name << endl << endl
                type = mkType(_lastToken.loc, typeString + "Type", name asStringRef, NodePtr())
                var list = NodePtr()
                while true
                    if !parseStructDeclaration(this, list)
                        break

                decl = mkStructDecl(loc, typeString + "Decl", name asStringRef, list)
                this expect tkRCURLY
    
            else return false

            return true

        fun parseStructDeclaration(this: @SparrowParser, list: @NodePtr): Bool
            var decl, typeSpec, structDecl: NodePtr
            
            if !parseSpecifierQualifierList(this, typeSpec, structDecl)
                return false
            
            expect(this, parseStructDeclarator(this, typeSpec, decl), "expecting structDeclarator")
            list = addToNodeList(list, decl)

            while this accept tkCOMMA
                expect(this, parseStructDeclarator(this, typeSpec, decl), "expecting structDeclarator")
                list = addToNodeList(list, decl)

            this expect tkSEMICOLON
            return true

        fun parseSpecifierQualifierList(this: @SparrowParser, \
            typeSpec, structDecl: @NodePtr): Bool
            var typeQual: NodePtr

            if !(  parseTypeSpecifier(this, typeSpec)
                || parseTypeQualifier(this, typeQual)
                || parseStructOrUnionSpecifier(this, typeSpec, structDecl) 
                || parseEnumSpecifier(this, typeSpec, structDecl)
                )
                return false

            while true
                if !(  parseTypeSpecifier(this, typeSpec)
                    || parseTypeQualifier(this, typeQual)
                    || parseStructOrUnionSpecifier(this, typeSpec, structDecl) 
                    || parseEnumSpecifier(this, typeSpec, structDecl)
                    )
                    break;

            typeSpec->children.at(0) = typeQual
            return true

        fun parseStructDeclarator(this: @SparrowParser, type, res: @NodePtr): Bool
            var decl, const: Bool
            decl = parseDeclarator(this, NodePtr(), type, res)
            
            if this accept tkCOLON
                const = parseConstantExpression(this, res)

            // TODO
            return (decl || const)

        fun parseEnumSpecifier(this: @SparrowParser, type, decl: @NodePtr): Bool
            if !(this accept tkENUM)
                return false
            var loc  = _lastToken.loc

            if this accept tkIDENTIFIER
                var name = _lastToken.data
                type = mkType(_lastToken.loc, "Enum" + "Type", name asStringRef, NodePtr())

                if this accept tkLCURLY
                    var list, item: NodePtr
                    parseEnumerator(this, item)
                    list = addToNodeList(list, item)
                    while this accept tkCOMMA
                        parseEnumerator(this, item)
                        list = addToNodeList(list, item)
                    
                    this expect tkRCURLY
                    decl = mkStructDecl(loc, "Enum" + "Decl", name.asStringRef, list)

            else if this accept tkLCURLY
                var name: String = "enum"
                name = name + ulongToString(_lastToken.loc.start.line) + ulongToString(_lastToken.loc.start.col)
                type = mkType(_lastToken.loc, "Enum" + "Type", name asStringRef, NodePtr())

                var list, item: NodePtr
                parseEnumerator(this, item)
                list = addToNodeList(list, item)
                while this accept tkCOMMA
                    parseEnumerator(this, item)
                    list = addToNodeList(list, item)
                
                decl = mkStructDecl(loc, "Enum" + "Decl", name.asStringRef, list)
                this expect tkRCURLY

            else return false
            
            return true
        
        fun parseEnumerator(this: @SparrowParser, expr: @NodePtr): Bool            
            if !(this accept tkIDENTIFIER)
                return false

            var name = _lastToken.data
            var loc = _lastToken.loc
            var init: NodePtr

            if this accept tkEQUAL
                expect(this, parseConstantExpression(this, init), "expecting parseConstantExpression")

            expr = mkEnumerator(loc, name asStringRef, init)
            return true

        fun parseDeclarator(this: @SparrowParser, storSpec, typeSpec, res: @NodePtr): Bool
            parsePointer(this, typeSpec)
            if !parseDirectDeclarator(this, storSpec, typeSpec, res)
                return false
            
            return true

        fun parseDirectDeclarator(this: @SparrowParser, storSpec, typeSpec, res: @NodePtr): Bool
            var identif: Token
            var name: String
            var loc: Location
            var isFunc: Bool = false
            var params: NodePtr
            var init: NodePtr

            // Get Var/Func Name    
            if this accept tkIDENTIFIER
                identif = _lastToken
                name ctor _lastToken.data
                loc = _lastToken.loc
            
            /* '(' declarator ')' */
            else if ((this nextIs tkLPAREN) && (this next2Is tkMUL))
                this accept tkLPAREN
                //expect(this, parseDeclarator(this, storSpec, typeSpec, res), "expecting declarator")
                this expect tkMUL
                this expect tkIDENTIFIER
                identif = _lastToken
                this expect tkRPAREN

                _typeNameListIgnore += identif.data

            else return false

            while true
                // ParserArrayType
                if this nextIs tkLBRACKET
                    parseArrayType(this, typeSpec)

                /*
                if this accept tkLBRACKET
                    this expect tkRBRACKET
                    var size: NodePtr
                    typeSpec = mkArrayType(_lastToken.loc, typeSpec, size)
                */

                else if this accept tkLPAREN
                    isFunc = true
                    params = NodePtr()
                    if this accept tkRPAREN
                        continue
                    
                    expect(this, (parseParameterList(this, params)
                                 || parseIdentifierList(this)
                                 ), "expecting IdentifList or ParameterList")
                    this expect tkRPAREN

                else break

            if storSpec isSet
                if storSpec->kind.asStringRef == "Typedef"
                    // TODO
                    if isFunc
                        res = mkFunDecl(loc, name.asStringRef, typeSpec, storSpec, params, NodePtr())
                        res->kind = String("skipThis")
                        return true

                    _typeNameList += name
                    res = mkTypedef(loc, name.asStringRef, typeSpec)
                    return true

            if !isFunc ; res = mkVarDecl(loc, name.asStringRef, typeSpec, storSpec, init)
            else res = mkFunDecl(loc, name.asStringRef, typeSpec, storSpec, params, NodePtr())

            if _ignore
                res->kind = String("skipThis")

            return true
        
        fun parseArrayType(this: @SparrowParser, typeSpec: @NodePtr)
            var size, listQual: NodePtr
            this accept tkLBRACKET

            if this nextIs tkRBRACKET
                // Nothing to DO

            else if this accept tkMUL
                //size = mkType(_lastToken.loc, )

            else if this accept tkSTATIC
                expect(this, isTypeQualifier(this, 0), "expecting typeQual")
                parseTypeQualifierList(this, listQual)
                expect(this, parseAssignmentExpression(this, size), "expecting assignmentExpression")

            else if isTypeQualifier(this, 0)
                parseTypeQualifierList(this, listQual)
                if this nextIs tkRBRACKET
                    // Nothing to DO
                else if this accept tkMUL
                    // size = 
                else
                    expect(this, parseAssignmentExpression(this, size), "assignment")

            else
                expect(this, parseAssignmentExpression(this, size), "expecting assignment")

            this expect tkRBRACKET
            typeSpec = mkArrayType(_lastToken.loc, typeSpec, listQual, size)

        fun parseTypeQualifierList(this: @SparrowParser, list: @NodePtr)
            var qual: NodePtr
            while parseTypeQualifier(this, qual)
                list = addToNodeList(list, qual)

        fun parsePointer(this: @SparrowParser, typeSpec: @NodePtr): Bool
            if !(this nextIs tkMUL)
                return false

            while this accept tkMUL
                var typeQual: NodePtr
                while true 
                    if !parseTypeQualifier(this, typeQual) ; break
                typeSpec = mkPtrType(_lastToken.loc, typeSpec, typeQual)

            return true
        
        fun parseParameterList(this: @SparrowParser, res: @NodePtr): Bool
            var r: Bool
            var parameter: NodePtr
            if !parseParameterDeclaration(this, parameter)
                return false

            //TODO
            if (parameter->kind.asStringRef == "PrimitiveType" 
             && parameter->name.asStringRef == "Void"
             )
                return true

            res = addToNodeList(res, parameter)
            while this accept tkCOMMA
                if this accept tkELLIPSIS
                    _ignore = true
                    res = addToNodeList(res, mkIdentifier(_lastToken.loc, "ellipsis"))
                    break
                expect(this, parseParameterDeclaration(this, parameter), "expecting ellipsis or paramDeclaration")
                res = addToNodeList(res, parameter)

            return true

        fun parseParameterDeclaration(this: @SparrowParser, node: @NodePtr): Bool
            var res: Bool
            var decl: NodePtr
            var storSpec, typeSpec, structDecl, funcSpec: NodePtr

            if !parseDeclarationSpecifiers(this, storSpec, typeSpec, structDecl, funcSpec)
                return false

            if parseDeclarator(this, storSpec, typeSpec, decl) //|| parseAbstractDeclarator(this))
                node = decl
            // TODO
            //else if parseAbstractDeclarator(this)
            else node = typeSpec
            
            return true
        
        fun parseIdentifierList(this: @SparrowParser): Bool
            var res: Bool
            if this accept tkIDENTIFIER
                res = true
            else
                return false

            while this accept tkCOMMA
                this expect tkIDENTIFIER

            return true

        fun parseTypeName(this: @SparrowParser, res: @NodePtr): Bool
            var decl, typeSpec, structDecl: NodePtr
            if !parseSpecifierQualifierList(this, typeSpec, structDecl)
                return false

            //parseAbstractDeclarator(this)

            return true

        fun parseAbstractDeclarator(this: @SparrowParser, typeSpec: @NodePtr): Bool
            parsePointer(this, typeSpec)
            if !parseDirectAbstractDeclarator(this, typeSpec)
                return false

            return true
        
        //TODO
        fun parseDirectAbstractDeclarator(this: @SparrowParser): Bool
            var res: Bool
            res = false
            if this accept tkLPAREN
                res = true
                var res2 = ( parseAbstractDeclarator(this)
                     || parseParameterList(this)
                     )
                this expect tkRPAREN

            else if this accept tkLBRACKET
                res = parseConstantExpression(this)
                this expect tkRBRACKET

            parseDirectAbstractDeclaratorOpt(this)
            return res

        fun parseDirectAbstractDeclaratorOpt(this: @SparrowParser): Bool
            while true
                if this accept tkLPAREN
                    parseParameterList(this)
                    this expect tkRPAREN
                else if this accept tkLBRACKET
                    parseConstantExpression(this)
                    this expect tkRBRACKET
                else
                    break

            return true
        
        //TODO
        fun parseDesignatorList(this: @SparrowParser): Bool
            return true

        fun parseDesignator(this: @SparrowParser): Bool
            if this accept tkLBRACKET
                expect(this, parseConstantExpression(this), "expecting parseConstantExpression")
                this expect tkRBRACKET
                return true

            else if this accept tkDOT
                this expect tkIDENTIFIER
                return true

            return false


        fun parseStmt(this: @SparrowParser, res: NodePtr): Bool
            if !(parseLabeledStmt(this, res)   ||
                 parseCompoundStmt(this, res)  ||
                 parseSelectionStmt(this, res) ||
                 parseIterationStmt(this, res) ||
                 parseJumpStmt(this, res)      ||
                 parseExpressionStmt(this, res)
                )
                return false
            
            return true
        
        fun parseDeclaration(this: @SparrowParser, decl: @NodePtr): Bool
            var storSpec, typeSpec, structDecl, funcSpec: NodePtr
            
            if !parseDeclarationSpecifiers(this, storSpec, typeSpec, structDecl, funcSpec)
                return false
            
            //if structDecl isSet
            //    resNodes = addToNodeList(resNodes, structDecl)

            if (this accept tkSEMICOLON)
                return true
            
            expect(this, parseInitDeclarator(this, storSpec, typeSpec, decl), "expecting initDeclarator")
            return true

        fun parseInitDeclarator(this: @SparrowParser, storSpec, typeSpec, res: NodePtr): Bool
            var decl: NodePtr
            var init: NodePtr
            if !parseDeclarator(this, storSpec, typeSpec, decl)
                return false

            // Parse Variable initializer
            if this accept tkEQUAL
                parseInitializer(this, init)
                decl->children.at(2) = init

            this expect tkSEMICOLON
            return true
        
        fun consumeTokens(this: @SparrowParser)
            var paren = 1
            while paren > 0
                if (*_tokens).type == tkLCURLY
                    paren++
                else if (*_tokens).type == tkRCURLY
                    paren--
                _tokens++


        fun parseCompoundStmt(this: @SparrowParser, res: @NodePtr): Bool
            var res: NodePtr
            if this accept tkLCURLY
                /////////////////
                consumeTokens(this)
                return true

                if this accept tkRCURLY
                    return true
                else
                    expect(this, parseBlockItemList(this, res), "expecting parseBlockItemList")
                    this expect tkRCURLY
                    return true

            return false
        

        fun parseBlockItemList(this: @SparrowParser, res: @NodePtr): Bool
            var item: NodePtr
            return false
            if !(parseDeclaration(this, item) || parseStmt(this, item))
                return false
            res = addToNodeList(res, item)

            //while true
            //    if !(parseDeclaration(this, item) || parseStmt(this, item))
            //        break
            //    res = addToNodeList(res, item)

            return true


        fun parseExpressionStmt(this: @SparrowParser, res: @NodePtr): Bool
            if this accept tkSEMICOLON
                return true

            if parseExpression(this, res)
                this expect tkSEMICOLON
                return true

            return false

        fun parseLabeledStmt(this: @SparrowParser, res: @NodePtr): Bool
            // TODO
            /*
            if this nextIs tkIDENTIFIER && next2Is tkCOLON
                this accept tkIDENTIFIER
                this accept tkCOLON
                expect(this, parseStmt(this), "Expecting parseStmt")

            else if this accept tkCASE
                expect(this, parseConstantExpression(this), "Expecting parseConstantExpression")
                this expect tkCOLON
                expect(this, parseStmt(this), "Expecting parseStmt")

            else if this accept tkDEFAULT
                this expect tkCOLON
                res = parseStmt(this)
            */

            return false
            

        fun parseSelectionStmt(this: @SparrowParser, res: @NodePtr): Bool
            if this accept tkIF
                var loc = _lastToken.loc
                var expr, thenClause, elseClause: NodePtr
                this expect tkLPAREN
                expect(this, parseExpression(this, expr), "Expecting expression")
                this expect tkRPAREN
                expect(this, parseStmt(this, thenClause), "Expecting parseStmt")

                if this accept tkELSE
                    expect(this, parseStmt(this, elseClause), "Expecting parseStmt")

                res = mkIfStmt(loc, expr, thenClause, elseClause)
                return true

            //TODO
            /*
            if this accept tkSWITCH
                this expect tkLPAREN
                expect(this, parseExpression(this), "Expecting expression")
                this expect tkRPAREN
                expect(this, parseStmt(this), "Expecting parseStmt")
                return true
            */

            return false

        fun parseIterationStmt(this: @SparrowParser, res: @NodePtr): Bool
            if this accept tkWHILE
                var loc = _lastToken.loc
                var expr, body: NodePtr
                this expect tkLPAREN
                expect(this, parseExpression(this, expr), "Expecting parseExpr")
                this expect tkRPAREN
                expect(this, parseStmt(this, body), "Expecting parseStmt")

                res = mkWhileStmt(loc, expr, body)
                return true

            if this accept tkDO
                var loc = _lastToken.loc
                var expr, body: NodePtr
                expect(this, parseStmt(this, body), "Expecting parseStmt")
                this expect tkWHILE
                this expect tkLPAREN
                expect(this, parseExpression(this, expr), "Expecting parseExpr")
                this expect tkRPAREN
                this expect tkSEMICOLON

                res = mkDoWhileStmt(loc, expr, body)
                return true

            if this accept tkFOR
                var loc = _lastToken.loc
                var expr, body: NodePtr
                this expect tkLPAREN
                //parseDeclaration(this, expr)
                parseExpressionStmt(this, expr)
                parseExpressionStmt(this, expr)
                if this accept tkRPAREN
                    //parseStmt(this)
                    return true
                else
                    parseExpressionStmt(this, expr)
                    this expect tkLPAREN
                    //parseStmt(this)
                    return true
                return true

            return false

        fun parseJumpStmt(this: @SparrowParser, res: @NodePtr): Bool
            //TODO
            if this accept tkGOTO
                this expect tkIDENTIFIER
                this expect tkSEMICOLON
                return true

            else if this accept tkCONTINUE
                res = mkContinueStmt(_lastToken.loc)
                this expect tkSEMICOLON
                return true

            else if this accept tkBREAK
                res = mkBreakStmt(_lastToken.loc)
                this expect tkSEMICOLON
                return true

            else if this accept tkRETURN
                var loc = _lastToken.loc
                var expr: NodePtr
                if this accept tkSEMICOLON
                    res = mkReturnStmt(loc, expr)
                else
                    expect(this, parseExpression(this, expr), "Expecting parseExpr")
                    this expect tkSEMICOLON

                    res = mkReturnStmt(loc, expr)
                return true

            return false
