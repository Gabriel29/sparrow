import parserDefs, token, rangeWithLookahead, nodes
import meta.location
import bitOper
import os

/// Our main parser
///
/// Takes as an input a range of tokens (produced by the scanner) and produces
/// a node as a result. The node is in fast and AST (tree).
///
/// All the nodes are created outside the parser; we only care about node pointers
///
[rtct]
class SparrowParser(tokensRangeType, errorReporterType: Type) \
        if TokenRange(#$tokensRangeType) && ErrorReporter(#$errorReporterType)

    fun ctor(tokens: tokensRangeType, errorReporter: errorReporterType)
        this._tokens ctor tokens
        this._hasErrors ctor false
        this._errorReporter ctor errorReporter

    /// The source ranges of tokens we will used while parsing
    var _tokens: RangeWithLookahead(tokensRangeType)
    /// The last processed token
    var _lastToken: Token
    /// Indicates whether we have some syntax errors
    var _hasErrors: Bool
    /// Object used to report errors
    var _errorReporter: errorReporterType

using parseHeader = _Impl.parseHeader

package _Impl
    [rtct]
        fun reportError(this: @SparrowParser, msg: StringRef)
            // Report the error
            _errorReporter.reportError((*_tokens).loc, msg)
            // Consume all the tokens until the end of the file
            while (*_tokens).type != TokenType(0) //tkEND
                _lastToken = (_tokens++)
            _hasErrors = true

        fun curLoc(this: @SparrowParser) = (*_tokens).loc
        fun lastLoc(this: @SparrowParser) = _lastToken.loc

        fun nextIs(this: @SparrowParser, t: TokenType): Bool = (*_tokens).type == t
        fun next2Is(this: @SparrowParser, t: TokenType): Bool = (_tokens peek 1).type == t

        fun accept(this: @SparrowParser, t: TokenType): Bool
            if (*_tokens).type == t
                _lastToken = (_tokens++)
                //cout << "Accepted " << _lastToken.type << endl

                return true
            return false

        fun expect(this: @SparrowParser, t: TokenType): Bool
            // Everything is ok if this is the token we are expecting
            if this accept t
                return true
            if _hasErrors  // Already inside an error; don't do anything
                return false
            // Report error if this token is now what we expected
            
            //TODO
            //this reportError toString("Syntax error, unexpected ", (*_tokens).type, ", expecting ", t)
            return false

        //TODO - Check why @String not working for Return Type
        fun expect(this: @SparrowParser, b: Bool, msg: StringRef): Bool 
            if b == false
                this reportError msg
            return true

        // Top level parsing
        fun parseHeader(this: @SparrowParser): NodePtr
            var res = parseExtDecls(this)
            this expect TokenType(0) //tkEND

            return res

        fun parsePrimaryExpression(this: @SparrowParser, expr: @NodePtr): Bool
            if this accept TokenType(2) //tkIDENTIFIER
                expr = mkIdentifier(_lastToken.loc, _lastToken.data asStringRef)
                return true

            else if this accept TokenType(4) //tkSTRING_LITERAL
                expr = mkStringLiteral(_lastToken.loc, _lastToken.data asStringRef)
                return true

            else if this accept TokenType(200) //tkCHAR_LITERAL
                expr = mkCharLiteral(_lastToken.loc, _lastToken.data asStringRef)
                return true

            else if this accept TokenType(201) //tkINT_LITERAL
                expr = mkIntLiteral(_lastToken.loc, _lastToken.intData)
                return true

            else if this accept TokenType(202) //tkUINT_LITERAL
                expr = mkUIntLiteral(_lastToken.loc, _lastToken.intData)
                return true

            else if this accept TokenType(203) //tkFLOAT_LITERAL
                expr = mkFloatLiteral(_lastToken.loc, _lastToken.floatData)
                return true

            else if this accept TokenType(205) //tkDOUBLE_LITERAL
                expr = mkDoubleLiteral(_lastToken.loc, _lastToken.floatData)
                return true

            //else if this accept tkCONSTANT
            //    return true

            else if this accept TokenType(74) //tkLPAREN
                //parseExpression(this)
                this expect TokenType(75) //tkRPAREN
                return true
            
            return false

        fun parsePostfixExpression(this: @SparrowParser, expr: @NodePtr): Bool
            if this accept TokenType(74) //tkLPAREN
                var typeName, list: NodePtr
                //parseTypeName(this, typeName)
                this expect TokenType(69) //tkLCURLY
                //expect(this, parseInitializerList(this, list), "expecting initializer list")
                this accept TokenType(71) //tkCOMMA
                this expect TokenType(70) //tkRCURLY
                this expect TokenType(75) //tkRPAREN
                return true

            if !parsePrimaryExpression(this, expr)
                return false

            /*while 
                if this accept tkLBRACKET
                    this expect tkRBRACKET
                else if this accept tkLPAREN
                    parseArgumentExpressionlist(this)
                    this expect tkRPAREN
                else if this accept tkDOT
                    this expect tkIDENTIFIER
                else if this accept tkPTR_OP
                    this expect tkIDENTIFIER
                else if this accept tkINC_OP
                    break
                else if this accept tkDEC_OP
                    break
                else
                    break
            */

            return true
        
        //TODO
        fun parseArgumentExpressionlist(this: @SparrowParser): Bool
            var res: Bool
            res = parseAssignmentExpression(this)

            while this accept TokenType(71) //tkCOMMA
                parseAssignmentExpression(this)

            if res == true
                return true

            this reportError toString("Syntax error, unexpected ", (*_tokens).type, ", expecting AssignExpr")

        fun parseUnaryExpression(this: @SparrowParser, expr: @NodePtr): Bool
            if this accept TokenType(11) //tkINC_OP
                expect(this, parseUnaryExpression(this, expr), "expecting unary expression")
                expr = mkUnaryExpr(_lastToken.loc, expr, "++")
            else if this accept TokenType(12) //tkDEC_OP
                expect(this, parseUnaryExpression(this, expr), "expecting unary expression")
                expr = mkUnaryExpr(_lastToken.loc, expr, "--")

            else if this accept tkSIZEOF
                if this accept TokenType(74) //tkLPAREN
                    var typeName: NodePtr
                    //expect(this, parseTypeName(this, typeName), "expecting TypeName")
                    this expect TokenType(75) //tkRPAREN
                    return true
                else
                    expect(this, parseUnaryExpression(this, expr), "expecting unary expression")

            else if parseUnaryOperator(this)
                var loc = _lastToken.loc
                var op  = _lastToken.data
                expect(this, parseCastExpression(this, expr), "expecting cast expression")
                expr = mkUnaryExpr(_lastToken.loc, expr, op asStringRef)
            
            return parsePostfixExpression(this, expr)
                
        fun parseUnaryOperator(this: @SparrowParser): Bool
            if  (  (this accept TokenType(79)) //tkAMPERSAND)
                || (this accept TokenType(84)) //tkMUL)
                || (this accept TokenType(83)) //tkPLUS)
                || (this accept TokenType(82)) //tkMINUS)
                || (this accept TokenType(81)) //tkTILDA)
                || (this accept TokenType(80)) //tkNOT)
                )
                return true

            return false

        fun parseCastExpression(this: @SparrowParser, expr: @NodePtr): Bool
            while this accept TokenType(74) //tkLPAREN
                var typeToCast: NodePtr
                //parseTypeName(this, typeToCast)
                expr = mkCast(_lastToken.loc, typeToCast, expr)
                this expect TokenType(75) //tkRPAREN

            return parseUnaryExpression(this, expr)

        fun isBinOp(this: @SparrowParser): Bool
            if  (  (this accept TokenType(84)) //tkMUL)
                || (this accept TokenType(85)) //tkDIV)
                || (this accept TokenType(86)) //tkMOD)
                || (this accept TokenType(83)) //tkPLUS)
                || (this accept TokenType(82)) //tkMINUS)
                || (this accept TokenType(13)) //tkLEFT_OP)
                || (this accept TokenType(14)) //tkRIGHT_OP)
                || (this accept TokenType(87)) //tkLT)
                || (this accept TokenType(88)) //tkGT)
                || (this accept TokenType(15)) //tkLE_OP)
                || (this accept TokenType(16)) //tkGE_OP)
                || (this accept TokenType(17)) //tkEQ_OP)
                || (this accept TokenType(18)) //tkNE_OP)
                || (this accept TokenType(79)) //tkAMPERSAND)
                || (this accept TokenType(89)) //tkXOR)
                || (this accept TokenType(90)) //tkOR)
                || (this accept TokenType(19)) //tkAND_OP)
                || (this accept TokenType(20)) //tkOR_OP)
                //|| (this accept tkQMARK)
                )
                return true

            return false

        fun binExprOp(this: @SparrowParser, expr: @NodePtr): Bool
            if !parseCastExpression(this, expr)
                return false

            while this isBinOp
                var name = _lastToken.data
                var loc  = _lastToken.loc
                var expr2: NodePtr
                expect(this, parseCastExpression(this, expr2),
                        "expected Logical And Expression")
                expr = mkBinOper(loc, expr, expr2, name.asStringRef)

            return true

        /*
        fun parseConditionalExpression(this: @SparrowParser): Bool
            var res: Bool
            res = parseLogicalOrExpression(this)

            if res == true && (this accept tkQMARK)
                parseExpression(this)
                this expect tkCOLON
                parseConditionalExpression(this)

            return res
        */
        
        fun parseAssignmentExpression(this: @SparrowParser, init: @NodePtr): Bool
            //while (parseUnaryExpression(this) && parseAssignmentOperator(this))
            //    continue

            if !binExprOp(this, init)
                return true

            return false

        fun parseAssignmentOperator(this: @SparrowParser): Bool
            if this accept tkEQUAL
                return true
            else if this accept TokenType(21) //tkMUL_ASSIGN
                return true
            else if this accept TokenType(22) //tkDIV_ASSIGN
                return true
            else if this accept TokenType(23) //tkMOD_ASSIGN
                return true
            else if this accept TokenType(24) //tkADD_ASSIGN
                return true
            else if this accept TokenType(25) //tkSUB_ASSIGN
                return true
            else if this accept TokenType(26) //tkLEFT_ASSIGN
                return true
            else if this accept TokenType(27) //tkRIGHT_ASSIGN
                return true
            else if this accept TokenType(28) //tkAND_ASSIGN
                return true
            else if this accept TokenType(29) //tkXOR_ASSIGN
                return true
            else if this accept TokenType(30) //tkOR_ASSIGN
                return true

            return false

        fun parseExpressionOpt(this: @SparrowParser): Bool
            var res: Bool
            res = parseAssignmentExpression(this)
            while this accept TokenType(71) //tkCOMMA
                parseAssignmentExpression(this)

            return res

        fun parseExpression(this: @SparrowParser): Bool
            var res: Bool
            res = parseAssignmentExpression(this)
            while this accept TokenType(71) //tkCOMMA
                parseAssignmentExpression(this)

            return res

        fun parseConstantExpression(this: @SparrowParser): Bool
            return parseConditionalExpression(this)
        
        fun parseExtDecls(this: @SparrowParser): NodePtr
            var node = mkExtDecls()

            while true
                var type, decl, init: NodePtr
                var storSpec, typeSpec, typeQual, structDecl: NodePtr
                
                if !parseDeclarationSpecifiers(this, storSpec, typeSpec, typeQual, structDecl)
                    break
                
                type = mkType(_lastToken.loc, typeSpec->kind asStringRef, 
                    typeSpec->name asStringRef, typeQual)
                
                if structDecl isSet
                    node = addToNodeList(node, structDecl)

                if (this accept TokenType(68)) //tkSEMICOLON)
                    continue
                
                expect(this, parseDeclarator(this, type, decl), "expecting declarator")
                
                if this accept TokenType(73) //tkEQUAL
                    parseInitializer(this, init)
                    // VarDecl Only 
                    decl->children.at(1) = storSpec
                    decl->children.at(2) = init
                
                node = addToNodeList(node, decl)

                while this accept TokenType(71) //tkCOMMA
                    expect(this, parseDeclarator(this, type, decl), "expecting declarator")
                    if this accept TokenType(73) //tkEQUAL
                        parseInitializer(this, init)
                        decl->children.at(1) = storSpec
                        decl->children.at(2) = init
                    
                    node = addToNodeList(node, decl)

                this expect TokenType(68) //tkSEMICOLON

            return node

        fun parseInitializer(this: @SparrowParser, init: @NodePtr): Bool
            if this accept TokenType(69) //tkLCURLY
                //expect(this, parseInitializerList(this), "Expecting parseInitializerList")
                this accept TokenType(71) //tkCOMMA
                this expect TokenType(70) //tkRCURLY
                return true
            else if parseAssignmentExpression(this, init)
                return true

            return false

        /*
        fun parseInitDeclarator(this: @SparrowParser, type, res: NodePtr): Bool
            var decl: NodePtr
            var init: NodePtr

            cout << "Start parseInitDeclarator" << endl
            if !parseDeclarator(this, type, decl)
                return false
            /* 
            if this accept tkEQUAL
                parseInitializer(this, init)
            * /
            res = mkDeclList(decl.loc, decl)
            while this accept tkCOMMA
                expect(this, parseDeclarator(this, type, decl), "expected fun/var")
                res = addToNodeList(res, decl)

            //res = mkInitDeclarator(_lastToken.loc, decl, init)

            cout << "End parseInitDeclarator" << endl
            return true
        */

        fun parseDeclarationSpecifiers(this: @SparrowParser, \
                storSpec, typeSpec, typeQual, structDecl: @NodePtr): Bool
            if !( parseStorageClassSpecifier(this, storSpec)
                    || parseTypeSpecifier(this, typeSpec)
                    || parseTypeQualifier(this, typeQual)
                    || parseStructOrUnionSpecifier(this, typeSpec, structDecl) 
                    || parseEnumSpecifier(this, typeSpec, structDecl)
                    )
                return false

            while true
                if !(parseStorageClassSpecifier(this, storSpec)
                    || parseTypeSpecifier(this, typeSpec)
                    || parseTypeQualifier(this, typeQual)
                    || parseStructOrUnionSpecifier(this, typeSpec, structDecl) 
                    || parseEnumSpecifier(this, typeSpec, structDecl)
                    )
                    break;

            ///node = mkPrimitiveType(_lastToken.loc, "Typedef")
            return true

        fun parseStorageClassSpecifier(this: @SparrowParser, list: @NodePtr): Bool
            if this accept TokenType(31) //tkTYPEDEF
                list = addToNodeList(list, new(Node, _lastToken.loc, "Typedef"))
                return true
            if this accept TokenType(32) //tkEXTERN
                list = addToNodeList(list, new(Node, _lastToken.loc, "Extern"))
                return true
            if this accept TokenType(33) //tkSTATIC
                list = addToNodeList(list, new(Node, _lastToken.loc, "Static"))
                return true
            if this accept TokenType(34) //tkAUTO
                list = addToNodeList(list, new(Node, _lastToken.loc, "Auto"))
                return true
            if this accept TokenType(35) //tkREGISTER
                list = addToNodeList(list, new(Node, _lastToken.loc, "Register"))
                return true

            return false

        fun parseTypeSpecifier(this: @SparrowParser, type: @NodePtr): Bool
            if this accept TokenType(67) //tkVOID
                type = mkType(_lastToken.loc, "PrimitiveType", "Void", NodePtr())
                return true
            if this accept TokenType(40) //tkCHAR
                type = mkType(_lastToken.loc, "PrimitiveType", "Char", NodePtr())
                return true
            if this accept TokenType(41) //tkSHORT
                type = mkType(_lastToken.loc, "PrimitiveType", "Short", NodePtr())
                return true
            if this accept TokenType(42) //tkINT
                type = mkType(_lastToken.loc, "PrimitiveType", "Int", NodePtr())
                return true
            if this accept TokenType(43) //tkLONG
                type = mkType(_lastToken.loc, "PrimitiveType", "Long", NodePtr())
                return true
            if this accept TokenType(46) //tkFLOAT
                type = mkType(_lastToken.loc, "PrimitiveType", "Float", NodePtr())
                return true
            if this accept TokenType(47) //tkDOUBLE
                type = mkType(_lastToken.loc, "PrimitiveType", "Double", NodePtr())
                return true
            if this accept TokenType(44) //tkSIGNED
                type = mkType(_lastToken.loc, "PrimitiveType", "Signed", NodePtr())
                return true
            if this accept TokenType(45) //tkUNSIGNED
                type = mkType(_lastToken.loc, "PrimitiveType", "Unsigned", NodePtr())
                return true
            if this accept TokenType(6) //tkTYPE_NAME
                type = mkType(_lastToken.loc, "PrimitiveType", "TypeName", NodePtr())
                return true
            return false
        
        fun parseTypeQualifier(this: @SparrowParser, list: @NodePtr): Bool
            if this accept TokenType(48) //tkCONST
                list = addToNodeList(list, new(Node, _lastToken.loc, "Const"))
                return true
            else if this accept TokenType(49) //tkVOLATILE
                list = addToNodeList(list, new(Node, _lastToken.loc, "Volatile"))
                return true

            return false
        
        fun parseStructOrUnionSpecifier(this: @SparrowParser, type, decl: @NodePtr): Bool
            var typeString: StringRef
            var loc: Location

            if this accept TokenType(50) //tkSTRUCT
                loc = _lastToken.loc
                typeString = "struct"
            else if this accept TokenType(51) //tkUNION
                loc = _lastToken.loc
                typeString = "union"
            else return false

            if this accept TokenType(2) //tkIDENTIFIER
                var name = _lastToken.data
                type = mkType(_lastToken.loc, typeString + "Type", name asStringRef, NodePtr())

                if this accept TokenType(69) //tkLCURLY
                    var item: NodePtr
                    decl = mkStructDecl(loc, typeString + "Decl", name asStringRef)
                    while parseStructDeclaration(this, item)
                        decl = addToNodeList(decl, item)
                    this expect TokenType(70) //tkRCURLY
            else
                this expect TokenType(69) //tkLCURLY
                this expect TokenType(70) //tkRCURLY
            /*
            else if this accept tkLCURLY
                parseStructDeclarationList(this)
                this expect tkRCURLY
            */
            return true

        fun parseStructDeclaration(this: @SparrowParser, decl: @NodePtr): Bool
            var typeSpec, typeQual, structDecl: NodePtr
            
            if !parseSpecifierQualifierList(this, typeSpec, typeQual, structDecl)
                return false
            
            expect(this, parseStructDeclarator(this, typeSpec, decl), "expecting StructDeclarator")
            //while this accept tkCOMMA
                //expect(this, parseStructDeclarator(this), "expecting declarator")

            this expect TokenType(68) //tkSEMICOLON
            return true

        fun parseSpecifierQualifierList(this: @SparrowParser, \
                typeSpec, typeQual, structDecl: @NodePtr): Bool
            if !(  parseTypeSpecifier(this, typeSpec)
                || parseTypeQualifier(this, typeQual)
                || parseStructOrUnionSpecifier(this, typeSpec, structDecl) 
                || parseEnumSpecifier(this, typeSpec, structDecl)
                )
                return false

            while true
                if !(  parseTypeSpecifier(this, typeSpec) 
                    || parseTypeQualifier(this, typeQual) )
                    break;
                //node = addToNodeList(typeQual, typeSpec)

            return true

        fun parseStructDeclarator(this: @SparrowParser, type, res: @NodePtr): Bool
            if !parseDeclarator(this, type, res)
                return false

            //TODO CONSTANT_EXPRESSION

            return true

        fun parseEnumSpecifier(this: @SparrowParser, type, decl: @NodePtr): Bool
            if !(this accept TokenType(52)) //tkENUM)
                return false

            if this accept TokenType(2) //tkIDENTIFIER
                var name = _lastToken.data
                var loc  = _lastToken.loc

                if this accept TokenType(69) //tkLCURLY
                    var item: NodePtr
                    decl = mkStructDecl(loc, "Enum" + "Decl", name.asStringRef)
                    while parseEnumerator(this, item)
                        decl = addToNodeList(decl, item)
                    this expect TokenType(70) //tkRCURLY

            else 
                this accept TokenType(69) //tkLCURLY
                this expect TokenType(70) //tkRCURLY

            return true
        
        fun parseEnumerator(this: @SparrowParser, decl: @NodePtr): Bool
            var name: String
            var loc : Location
            
            if !(this accept TokenType(2)) //tkIDENTIFIER)
                return false
            name = _lastToken.data
            loc = _lastToken.loc

            if this accept TokenType(73) //tkEQUAL
                //TODO
                //parseConstantExpression(this)
                return true

            decl = mkIdentifier(loc, name.asStringRef)
            return true

        fun parseDeclarator(this: @SparrowParser, type, res: @NodePtr): Bool
            var directDecl: NodePtr
            var newType: NodePtr = type

            parsePointer(this, newType)
            if !parseDirectDeclarator(this, newType, directDecl)
                return false
            
            res = directDecl
            return true

        fun parseDirectDeclarator(this: @SparrowParser, type, res: @NodePtr): Bool
            var name: String
            var loc: Location
            var isFunc: Bool = false
            var params: NodePtr
            var storage, init: NodePtr

            // Get Var/Func Name    
            if this accept TokenType(2) //tkIDENTIFIER
                name ctor _lastToken.data
                loc = _lastToken.loc
            else return false

            // TODO CAST
            /* '(' declarator ')' */
            /*
            else if this accept tkLPAREN
                res = true
                expect(this, parseDeclarator(this), "expecting declarator")
                this expect tkRPAREN
            */

            while true
                if this accept TokenType(76) //tkLBRACKET
                    this expect TokenType(77) //tkRBRACKET
                    var size: NodePtr
                    type = mkArrayType(_lastToken.loc, type, size)
                
                else if this accept TokenType(74) //tkLPAREN
                    isFunc = true
                    if this accept TokenType(75) //tkRPAREN
                        params = mkEmpty(_lastToken.loc)
                        continue
                    
                    expect(this, (parseIdentifierList(this)
                                 || parseParameterList(this, params)
                                 ), "expecting IdentifList or ParameterList")
                    this expect TokenType(75) //tkRPAREN

                else break

            if !isFunc ; res = mkVarDecl(loc, name.asStringRef, type, storage, init)
            else res = mkFunDecl(loc, name.asStringRef, type, storage, params, NodePtr())

            return true
        
        
        fun parsePointer(this: @SparrowParser, type: @NodePtr): Bool
            if !(this nextIs TokenType(84)) //tkMUL)
                return false

            while this accept TokenType(84) //tkMUL
                var typeQual: NodePtr
                while true 
                    if !parseTypeQualifier(this, typeQual) ; break
                type = mkPtrType(_lastToken.loc, type, typeQual)

            return true
        
        fun parseParameterList(this: @SparrowParser, res: @NodePtr): Bool
            var r: Bool
            var parameter: NodePtr
            if !parseParameterDeclaration(this, parameter)
                return false

            res = addToNodeList(res, parameter)
            while this accept TokenType(71) //tkCOMMA
                if this accept TokenType(53) //tkELLIPSIS
                    // TODO ELLIPSIS!
                    break
                expect(this, parseParameterDeclaration(this, parameter), "expecting ellipsis or paramDeclaration")
                res = addToNodeList(res, parameter)

            return true

        fun parseParameterDeclaration(this: @SparrowParser, node: @NodePtr): Bool
            var res: Bool
            var type: NodePtr
            var decl: NodePtr
            var storSpec, typeSpec, typeQual, structDecl: NodePtr

            if !parseDeclarationSpecifiers(this, storSpec, typeSpec, typeQual, structDecl)
                return false
            type = mkType(_lastToken.loc, typeSpec->kind asStringRef, 
                    typeSpec->name asStringRef, typeQual)

            if parseDeclarator(this, type, decl) //|| parseAbstractDeclarator(this))
                node = decl
            else node = type
            
            return true
        
        fun parseIdentifierList(this: @SparrowParser): Bool
            var res: Bool
            if this accept TokenType(2) //tkIDENTIFIER
                res = true
            else
                return false

            while this accept TokenType(71) //tkCOMMA
                this expect TokenType(2) //tkIDENTIFIER

            return true

        fun parseTypeName(this: @SparrowParser): Bool
            var res: Bool
            res = parseSpecifierQualifierList(this)
            if res == true
                parseAbstractDeclarator(this)
                return true

            return res
            //this reportError toString("Syntax error, unexpected ", (*_tokens).type, ", expecting TYPENAME")


        fun parseAbstractDeclarator(this: @SparrowParser): Bool
            var res: Bool
            //res = parsePointer(this)
            parseDirectAbstractDeclarator(this)

            return res
        
        //TODO
        fun parseDirectAbstractDeclarator(this: @SparrowParser): Bool
            var res: Bool
            res = false
            if this accept TokenType(74) //tkLPAREN
                res = true
                var res2 = ( parseAbstractDeclarator(this)
                     || parseParameterList(this)
                     )
                this expect TokenType(75) //tkRPAREN

            else if this accept TokenType(76) //tkLBRACKET
                res = parseConstantExpression(this)
                this expect TokenType(77) //tkRBRACKET

            parseDirectAbstractDeclaratorOpt(this)
            return res

        fun parseDirectAbstractDeclaratorOpt(this: @SparrowParser): Bool
            while true
                if this accept TokenType(74) //tkLPAREN
                    parseParameterList(this)
                    this expect TokenType(75) //tkRPAREN
                else if this accept TokenType(76) //tkLBRACKET
                    parseConstantExpression(this)
                    this expect TokenType(77) //tkRBRACKET
                else
                    break

            return true
        
        
        fun parseInitializerList(this: @SparrowParser): Bool
            var res: Bool
            
            res = ( parseDesignator(this)
                 || parseInitializer(this)
                 )

            while res == true && (this accept TokenType(71)) //tkCOMMA)
                parseDesignator(this)
                parseInitializer(this)

            return res

            //this reportError toString("Syntax error, unexpected ", (*_tokens).type, ", expecting parseInitializerList")
        
        //TODO
        fun parseDesignatorList(this: @SparrowParser): Bool
            return true

        fun parseDesignator(this: @SparrowParser): Bool
            if this accept TokenType(76) //tkLBRACKET
                expect(this, parseConstantExpression(this), "expecting parseConstantExpression")
                this expect TokenType(77) //tkRBRACKET
                return true

            else if this accept TokenType(78) //tkDOT
                this expect TokenType()tkIDENTIFIER
                return true

            return false


        //TODO
        fun parseStmt(this: @SparrowParser): Bool
            var res: Bool
            res = (parseLabeledStmt(this)
                || parseCompoundStmt(this)
                || parseSelectionStmt(this)
                || parseIterationStmt(this)
                || parseJumpStmt(this)
                || parseExprStmtOpt(this)
                )
            return res
        
        fun parseLabeledStmt(this: @SparrowParser): Bool
            var res: Bool
            if this nextIs TokenType(2) / && next2Is TokenType(71) //tkIDENTIFIER tkCOLON 
                this accept TokenType(2) //tkIDENTIFIER
                this accept TokenType(72) //tkCOLON
                expect(this, parseStmt(this), "Expecting parseStmt")

            else if this accept TokenType(54) //tkCASE
                expect(this, parseConstantExpression(this), "Expecting parseConstantExpression")
                this expect TokenType(72) //tkCOLON
                expect(this, parseStmt(this), "Expecting parseStmt")

            else if this accept TokenType(55) //tkDEFAULT
                this expect TokenType(72) //tkCOLON
                res = parseStmt(this)

            else
                res = false

            return res
        
        fun parseCompoundStmt(this: @SparrowParser): Bool
            var res: Bool
            if this accept TokenType(69) //tkLCURLY
                if this accept TokenType(70) //tkRCURLY
                    return true
                else
                    expect(this, parseBlockItemList(this), "Expecting parseBlockItemList")
                    this expect TokenType(70) //tkRCURLY
                    return true

            return false
        
        /*
        fun parseStmtList(this: @SparrowParser): Bool
            var res: Bool
            res = parseStmt(this)
            
            while true
                if parseStmt(this)
                    continue
                break

            return res
        */
        
        //TODO
        fun parseBlockItemList(this: @SparrowParser): Bool
            return false

        fun parseBlockItem(this: @SparrowParser): Bool
            var found: Bool
            found = (parseDeclaration(this)
                  || parseStmt(this)
                  )

            return found

        //TODO
        fun parseExprStmtOpt(this: @SparrowParser): Bool
            var res: Bool

            if this accept TokenType(68) //tkSEMICOLON
                return true

            if parseExpression(this)
                this expect TokenType(68) //tkSEMICOLON
                return true

            return false

        fun parseExprStmt(this: @SparrowParser): Bool
            var res: Bool
            res = parseExprStmt(this)
            if(res == true)
                return res

            this reportError toString("Syntax error, unexpected ", (*_tokens).type, ", expecting parseInitializerList")

        fun parseSelectionStmt(this: @SparrowParser): Bool
            if this accept tkIF
                this expect tkLPAREN
                expect(this, parseExpression(this), "Expecting expression")
                this expect tkRPAREN
                expect(this, parseStmt(this), "Expecting parseStmt")

                if this accept tkELSE
                    expect(this, parseStmt(this), "Expecting parseStmt")

                return true

            if this accept tkSWITCH
                this expect tkLPAREN
                expect(this, parseExpression(this), "Expecting expression")
                this expect tkRPAREN
                expect(this, parseStmt(this), "Expecting parseStmt")
                return true

            return false

        //TODO
        fun parseIterationStmt(this: @SparrowParser): Bool
            if this accept tkWHILE
                this expect tkLPAREN
                expect(this, parseExpression(this), "Expecting parseExpr")
                this expect tkRPAREN
                expect(this, parseStmt(this), "Expecting parseStmt")
                return true

            if this accept tkDO
                expect(this, parseStmt(this), "Expecting parseStmt")
                this expect tkLPAREN
                expect(this, parseExpression(this), "Expecting parseExpr")
                this expect tkRPAREN
                this expect tkSEMICOLON
                return true

            //TODO
            /*
            if this accept tkFOR
                this expect tkLPAREN
                parseExprStmt(this)
                parseExprStmt(this)
                if this accept tkRPAREN
                    parseStmt(this)
                    return true
                else
                    parseExpression(this)
                    this expect tkLPAREN
                    parseStmt(this)
                    return true
                return true
            */

            return false;

        fun parseJumpStmt(this: @SparrowParser): Bool
            if this accept tkGOTO
                this expect tkIDENTIFIER
                this expect tkSEMICOLON
                return true

            else if this accept tkCONTINUE
                this expect tkSEMICOLON
                return true

            else if this accept tkBREAK
                this expect tkSEMICOLON
                return true

            else if this accept tkRETURN
                if this accept tkSEMICOLON
                    return true
                else
                    expect(this, parseExpression(this), "Expecting parseExpr")
                this expect tkSEMICOLON
                return true

            return false

        /* TODO
        fun parseFunctionDefinition(this: @SparrowParser): Bool
            var res: Bool

            if parseDeclarationSpecifiers(this)
                parseDeclarator(this)
                parseDeclarationList(this)
                parseCompoundStmt(this)
                res = true
            else if parseDeclarator(this)
                parseDeclarationList(this)
                parseCompoundStmt(this)
                res = true
            else
                res = false

            return res
        
        fun parseDeclarationList(this: @SparrowParser): Bool
            var res: Bool
            res = parseDeclaration(this)

            while res == true
                if parseDeclaration(this)
                    continue
                break

            return res
        */
